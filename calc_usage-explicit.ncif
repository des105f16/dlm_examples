principal u;
principal ec;
principal a;

typedef struct usage {
  int {{u->u}} start_time;
  int {{u->u}} usageWh;
} usage;

typedef struct price {
  int {{ec->u, ec, a}} start_time;
  int {{ec->u, ec, a}} priceEars;
} price;

int {{u->ec}} calc_usage(usage {{_}} *usages, int {{_}} usages_count, price {{_}} *prices, int {{_}} prices_count) {
  int {{u->u}} result = 0; // ⊥

  int {{a->a}} i = 0;
  int {{a->a}} j = 0; // ⊥
  int {{a->}} j2 = 1;
  while (i < usages_count) { // i ⊔ j ⊔ usages_count = {{a->a, _->*}}
    while ((j < prices_count-1) && (prices[j2].start_time <= usages[i].start_time)) {
      j = j + 1; //i ⊔ j ⊔ prices_count ⊔ prices.start_time ⊔ usages.start_time = {{a->a, _->*, ec->*, u->u}}
      j2 = j2 + 1;
    } // j {{a->a, _->*, ec->*, u->u}}
    result = result + usages[i].usageWh * prices[j].priceEars; // i ⊔ j ⊔ usages_count = {{a->a, _->*}}
    i = i + 1;
  } // result {{a->a, _->*, u->u, ec->*}}

  calc_usage -->? u {
    return <|result, {{u->ec}}|>;
  }
  return -1;
}
