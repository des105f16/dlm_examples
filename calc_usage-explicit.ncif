principal u, ec, a;

typedef struct usage {
  int {{u->u}} start_time;
  int {{u->u}} usageWh;
} usage;

typedef struct price {
  int {{ec->*}} start_time;
  int {{ec->*}} priceEars;
} price;

int {{u->ec}} calc_usage(usage {{_->*}} *usages, int {{_->*}} usages_count, price {{_->*}} *prices, int {{_->*}} prices_count) {
  int {{u->u}} result = 0; // ⊥

  int {{a->a}} i, j; // ⊥
  for (i = 0, j = 0; i < usages_count; i++) { // i ⊔ j ⊔ usages_count = {{a->a, _->*}}
    while (j < prices_count-1 && prices[j+1].start_time <= usages[i].start_time) {
      j = j + 1; //i ⊔ j ⊔ prices_count ⊔ prices.start_time ⊔ usages.start_time = {{a->a, _->*, ec->*, u->u}}
    } // j {{a->a, _->*, ec->*, u->u}}
    result += usages[i].usageWh * prices[j].priceEars; // i ⊔ j ⊔ usages_count = {{a->a, _->*}}
  } // result {{a->a, _->*, u->u, ec->*}}

  if_acts_for(calc_usage, a) {
    return declassify(result, {u->ec});
  }
  return -1;
}
