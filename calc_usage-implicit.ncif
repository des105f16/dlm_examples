principal u, ec, a;

typedef struct usage {
  int {{u->u}} start_time;
  int {{u->u}} usageWh;
} usage;

typedef struct price {
  int {{ec->u, ec, a}} start_time;
  int {{ec->u, ec, a}} priceEars;
} price;

int {{usages; prices}} calc_usage(usage *usages, int {{_}} usages_count, price *prices, int {{_}} prices_count) {
  int result = 0; // ⊥ ⊑ result

  int i = 0; // ⊥ ⊑ i
  int j = 0; // ⊥ ⊑ j
  int j2 = 1;
  while (i < usages_count) { // ⊥ ⊑ i, j ; i ⊔ usages_count = L1 ; i ⊔ L1 ⊑ i
    while (j < prices_count-1 && prices[j2].start_time <= usages[i].start_time) { // j ⊔ prices_count ⊔ prices ⊔ {{ec->*}} ⊔ usages ⊔ {{u->u}} ⊔ i ⊔ L1 = L2
        j = j + 1; // L1 ⊔ L2 ⊔ j ⊑ j
        j2 = j2 + 1;
    }
    result = result + usages[i].usageWh * prices[j].priceEars; // result ⊔ usages ⊔ {{u->u}} ⊔ i ⊔ j ⊔ prices ⊔ {{ec->*}} ⊔ L1 ⊑ result
    i = i + 1;
  }

  this -->? u, ec {
    return <|result|>; // ⊥ | result ⊑ Ld ⊔ {{a->_, u->_, ec->_}} | Ld ⊑ {{usages ⊔ prices}}
  }
  return -1; // ⊥ ⊑ {{usages ⊔ prices}}
}
